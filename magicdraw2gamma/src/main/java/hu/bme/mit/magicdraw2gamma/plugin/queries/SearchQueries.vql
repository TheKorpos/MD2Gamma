package hu.bme.mit.magicdraw2gamma.plugin.queries


import "http://www.mit.bme.hu/gamma/statechart/Model" as GammaStatechart
import "http://www.mit.bme.hu/gamma/statechart/Model/Interface" as Gamma
import "http://www.mit.bme.hu/magicdraw2gamma/trace"
import "http://www.nomagic.com/magicdraw/UML/2.5.1"


pattern StateMachines(stateMachine: StateMachine, name: java String){
	StateMachine.name(stateMachine, name);
}

pattern ParametersInStateMachine(stateMachine: StateMachine, parameter: Parameter){
	StateMachine.ownedParameter(stateMachine, parameter);
}

pattern RegionsInRegion(container: Region, region: Region){
	Region.subvertex(container, vertex);
	State.region(vertex, region);
}

pattern RegionsInStatemachine(stateMachine: StateMachine, subregion: Region){
	find MainRegions(stateMachine, subregion);
} or {
	find RegionsInRegion+(region, subregion);
	StateMachine.region(stateMachine, region);
}

pattern StatesInStatemachine(stateMachine: StateMachine, state: State){
	find RegionsInStatemachine(stateMachine, region);
	Region.subvertex(region, state);
}

pattern TranisitonsInStateMachine(stateMachine: StateMachine, transition: Transition){
	find RegionsInStatemachine(stateMachine, region);
	Region.transition(region, transition);
}

pattern SignalsInStateMachine(stateMachine: StateMachine, signal: Signal, gInterface: Gamma::Interface){
	StateMachine.event(stateMachine, event);
	SignalEvent.signal(event, signal);
	InterfaceTrace.source(trace, stateMachine);
	InterfaceTrace.target(trace, gInterface);
}

pattern MainRegions(stateMachine: StateMachine, region: Region){
	StateMachine.region(stateMachine, region);
}

pattern StatesInMainRegion(region: Region, state: State){
	find MainRegions(_, region);
	Region.subvertex(region, state);
} 

pattern StatesInRegions(containingRegion: Region, state: State){
	Region.subvertex(containingRegion, state);
}

pattern PseudoStates(containingRegion: Region, pseudoState: Pseudostate, kind: PseudostateKind){
	Region.subvertex(containingRegion, pseudoState);
	Pseudostate.kind(pseudoState, kind);

}

pattern FinalStates(containingRegion: Region, finalState: FinalState){
	Region.subvertex(containingRegion, finalState);
}

pattern RegionsInStates(containingState: State, region: Region){
	State.region(containingState, region);
}

pattern Transitions(source: Vertex, transition: Transition, target: Vertex){
	Transition.source(transition, source);
	Transition.target(transition, target);
}


private pattern InnerRegion(region: Region, innerRegion: Region){
	find StatesInRegions(region, state);
	find RegionsInStates(state, innerRegion);
}

pattern RegionsInStatechart(stmt: StateMachine, region: Region){
	find MainRegions(stmt, region);
} or {
	find MainRegions(stmt, outerRegion);
	find InnerRegion+(outerRegion, region);
}

pattern OwnedTransitions(stmt: StateMachine, transition: Transition){
	find RegionsInStatechart(stmt, region);
	Region.transition(region, transition);
}

pattern Triggers(transition: Transition, trigger: Trigger){
	Transition.trigger(transition, trigger);
}

pattern Signals(trigger: Trigger, signal: Signal){
	Trigger.event(trigger, signalEvent);
	SignalEvent.signal(signalEvent, signal);
}

pattern GuardsInStateMachine(stateMachine: StateMachine, transition: Transition, opaqueExpression: OpaqueExpression, body: java String){
	find TranisitonsInStateMachine(stateMachine, transition);
	Transition.guard(transition, guard);
	Constraint.specification(guard, opaqueExpression);
	OpaqueExpression.body(opaqueExpression, body);
	check(!"".equals(body));
}

pattern TimeEventsInStateMachine(stateMachine: StateMachine, transition: Transition, event: TimeEvent){
	StateMachine.event(stateMachine, event);
	Transition.trigger(transition, trigger);
	Trigger.event(trigger, event);
}

pattern PropertiesInStateMachine(stateMachine: Class, prop: Property){
	Class.ownedAttribute(stateMachine, prop);
}

pattern Actions(action: Behavior, body: java String){
	FunctionBehavior.body(action, body);
} or {
	OpaqueBehavior.body(action, body);
} or {
	//any other
	neg FunctionBehavior(action);
	neg OpaqueBehavior(action);
	Behavior.name(action, body);
}

pattern ActionsOnTransitions(transition: Transition, body: java String, effect: Behavior){
	Transition.effect(transition, effect);
	find Actions(effect, body);
}

pattern EntryActions(state: State, body: java String, effect: Behavior){
	State.entry(state, effect);
	find Actions(effect, body);
}

pattern ExitActions(state: State, body: java String, effect: Behavior){
	State.exit(state, effect);
	find Actions(effect, body);
}

//pattern DoActions(state: State, body: java String, effect: Behavior){
//	State.do(state, effect);
//	find Actions(effect, body);
//}

pattern OwnedOperations(class: Class, operation: Operation, gInterface : Gamma::Interface){
	Class.ownedOperation(class, operation);
	InterfaceTrace.source(trace, class);
	InterfaceTrace.target(trace, gInterface);
}

pattern EventTriggers(transition: Transition, gEvent: Gamma::Event, gPort: GammaStatechart::Port){
	Transition.trigger.event(transition, callevent);
	CallEvent.operation(callevent, operation);
	InterfaceTrace.source(trace, operation);
	InterfaceTrace.target(trace, gEvent);
	GammaStatechart::Port.interfaceRealization.interface.events(gPort, gEventDecl);
	Gamma::EventDeclaration.event(gEventDecl, gEvent); 
} or {
	Transition.trigger.event(transition, signalEvent);
	SignalEvent.signal(signalEvent, signal);
	InterfaceTrace.source(trace, signal);
	InterfaceTrace.target(trace, gEvent);
	GammaStatechart::Port.interfaceRealization.interface.events(gPort, gEventDecl);
	Gamma::EventDeclaration.event(gEventDecl, gEvent);
}

pattern AnyEventTriggers(transition: Transition, anyEvent: AnyReceiveEvent, gTransition: GammaStatechart::Transition){
	Transition.trigger.event(transition, anyEvent);
	Trace.source(trace, transition);
	Trace.target(trace, gTransition);
}

pattern OpaqueTriggers(transition: Transition, trigger : Trigger, gTransition: GammaStatechart::Transition){
	Transition.trigger(transition, trigger);
	neg Trace.source(_, trigger);
	Trace.source(trace, transition);
	Trace.target(trace, gTransition);
}


