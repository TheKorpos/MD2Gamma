package hu.bme.mit.magicdraw2gamma.plugin.queries


import "http://www.mit.bme.hu/gamma/statechart/Model" as GammaStatechart
import "http://www.mit.bme.hu/gamma/statechart/Model/Interface" as Gamma
import "http://www.mit.bme.hu/magicdraw2gamma/trace"
import "http://www.nomagic.com/magicdraw/UML/2.5.1"


pattern StateMachines(stateMachine: StateMachine, name: java String){
	StateMachine.name(stateMachine, name);
}

pattern RegionsInRegion(container: Region, region: Region){
	Region.subvertex(container, vertex);
	State.region(vertex, region);
}

pattern RegionsInStatemachine(stateMachine: StateMachine, subregion: Region){
	find MainRegions(stateMachine, subregion);
} or {
	find RegionsInRegion+(region, subregion);
	StateMachine.region(stateMachine, region);
}

pattern StatesInStatemachine(stateMachine: StateMachine, state: State){
	find RegionsInStatemachine(stateMachine, region);
	Region.subvertex(region, state);
}

pattern TranisitonsInStateMachine(stateMachine: StateMachine, transition: Transition){
	find RegionsInStatemachine(stateMachine, region);
	Region.transition(region, transition);
}

pattern SignalsInStateMachine(block: Class, trigger: Trigger, signal: Signal, gInterface: Gamma::Interface){
	Class.classifierBehavior(block, stateMachine);
	find TranisitonsInStateMachine(stateMachine, transition);
	Transition.trigger(transition, trigger);
	Trigger.event(trigger, event);
	SignalEvent.signal(event, signal);
	InterfaceTrace.source(trace, block);
	InterfaceTrace.target(trace, gInterface);
}

pattern MainRegions(stateMachine: StateMachine, region: Region){
	StateMachine.region(stateMachine, region);
}

pattern StatesInMainRegion(region: Region, state: State){
	find MainRegions(_, region);
	Region.subvertex(region, state);
} 

pattern StatesInRegions(containingRegion: Region, state: State){
	Region.subvertex(containingRegion, state);
}

pattern PseudoStates(containingRegion: Region, pseudoState: Pseudostate, kind: PseudostateKind){
	Region.subvertex(containingRegion, pseudoState);
	Pseudostate.kind(pseudoState, kind);

}

pattern FinalStates(containingRegion: Region, finalState: FinalState){
	Region.subvertex(containingRegion, finalState);
}

pattern RegionsInStates(containingState: State, region: Region){
	State.region(containingState, region);
}

pattern Transitions(source: Vertex, transition: Transition, target: Vertex){
	Transition.source(transition, source);
	Transition.target(transition, target);
}


private pattern InnerRegion(region: Region, innerRegion: Region){
	find StatesInRegions(region, state);
	find RegionsInStates(state, innerRegion);
}

pattern RegionsInStatechart(stmt: StateMachine, region: Region){
	find MainRegions(stmt, region);
} or {
	find MainRegions(stmt, outerRegion);
	find InnerRegion+(outerRegion, region);
}

pattern OwnedTransitions(stmt: StateMachine, transition: Transition){
	find RegionsInStatechart(stmt, region);
	Region.transition(region, transition);
}

pattern Triggers(transition: Transition, trigger: Trigger){
	Transition.trigger(transition, trigger);
}

pattern Signals(trigger: Trigger, signal: Signal){
	Trigger.event(trigger, signalEvent);
	SignalEvent.signal(signalEvent, signal);
}

pattern GuardsInStateMachine(stateMachine: StateMachine, transition: Transition, opaqueExpression: OpaqueExpression, body: java String){
	find TranisitonsInStateMachine(stateMachine, transition);
	Transition.guard(transition, guard);
	Constraint.specification(guard, opaqueExpression);
	OpaqueExpression.body(opaqueExpression, body);
	check(!"".equals(body));
}

pattern TimeEventsInStateMachine(stateMachine: StateMachine, transition: Transition, event: TimeEvent){
	StateMachine.event(stateMachine, event);
	Transition.trigger(transition, trigger);
	Trigger.event(trigger, event);
}

pattern PropertiesInStateMachine(stateMachine: StateMachine, prop: Property){
	StateMachine.ownedAttribute(stateMachine, prop);
}

pattern ActionsOnTransitions(expression: FunctionBehavior, transition: Transition, statemachine: StateMachine, body: java String){
	Transition.effect(transition, expression);
	find TranisitonsInStateMachine(statemachine, transition);
	FunctionBehavior.body(expression, body);
	check(!"".equals(body));
}

pattern EntryActions(stateMachine: StateMachine, state: State, expression: FunctionBehavior, body: java String){
	State.entry(state, expression);
	find StatesInStatemachine(stateMachine, state);
	FunctionBehavior.body(expression, body);
	check(!"".equals(body));
}

pattern ExitActions(stateMachine: StateMachine, state: State, expression: FunctionBehavior){
	State.exit(state, expression);
	find StatesInStatemachine(stateMachine, state);
}

pattern DoActions(stateMachine: StateMachine, state: State, expression: FunctionBehavior){
	State.doActivity(state, expression);
	find StatesInStatemachine(stateMachine, state);
}

pattern OwnedOperations(class: Class, operation: Operation, gInterface : Gamma::Interface){
	Class.ownedOperation(class, operation);
	InterfaceTrace.source(trace, class);
	InterfaceTrace.target(trace, gInterface);
}

pattern EventTriggers(transition: Transition, gEvent: Gamma::Event, gPort: GammaStatechart::Port){
	Transition.trigger.event(transition, callevent);
	CallEvent.operation(callevent, operation);
	InterfaceTrace.source(trace, operation);
	InterfaceTrace.target(trace, gEvent);
	GammaStatechart::Port.interfaceRealization.interface.events(gPort, gEventDecl);
	Gamma::EventDeclaration.event(gEventDecl, gEvent);
} or {
	Transition.trigger.event(transition, signalEvent);
	SignalEvent.signal(signalEvent, signal);
	InterfaceTrace.source(trace, signal);
	InterfaceTrace.target(trace, gEvent);
	GammaStatechart::Port.interfaceRealization.interface.events(gPort, gEventDecl);
	Gamma::EventDeclaration.event(gEventDecl, gEvent);
}


